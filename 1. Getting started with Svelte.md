
## Introduction to Svelte

Svelte is a relatively new frontend JavaScript framework. Svelte is different from other popular frameworks like React, Angular, and Vue.js in that it is a compiler, not a runtime library. This means that instead of sending code to the client and having it run there, Svelte compiles your components into efficient JavaScript code that runs directly in the browser.

Svelte has several advantages:
1. Firstly, it is fast and lightweight. Because Svelte compiles your components into efficient JavaScript, your application will run quickly and smoothly. 
2. Secondly, it has a small learning curve compared to other frontend frameworks.
3. Finally, Svelte has a growing and supportive community.

## Setting up your development environment

To use Svelte, you will need to have Node.js and npm (node package manager) installed on your computer. Node.js is a JavaScript runtime environment, and npm is a package manager that helps you install and manage packages for your projects. 

To create a new Svelte project using npx:
```
npx degit sveltejs/template my-svelte-project
cd my-svelte-project
npm install
npm run dev
```

`npx` is a tool that allows you to execute npm packages, and `digit` is a package that allows you to clone and bootstrap a repository without Git. `sveltejs/template` is the repository that contains the Svelte project template, and `my-svelte-project` is the name of the directory that will be created for your new project.

`npm run` is a command that allows you to run scripts defined in the `scripts` section of your project's `package.json` file. `dev` is the name of the script that starts the development server.

After running `npm run dev`, Svelte will compile and build your application. It will start a local server. Svelte will watch for file updates, and automatically recompile and refresh the app for you when changes are made to the source files. 

## Application Structure

The starter template comes with the following structure:

```
my-svelte-project
├── README.md
├── package.json
├── package-lock.json
├── rollup.config.js
├── .gitignore
├── node_modules
├── public
│   ├── favicon.png
│   ├── index.html
│   ├── global.css
│   └── build
│       ├── bundle.css
│       ├── bundle.js
│       └── bundle.js.map
├── scripts
│   └── setupTypeScript.js
└── src
    ├── App.svelte
    └── main.js
```

The contents are as follows:
- `rollup.config.js`:  Svelte uses `rollup.js` as a module bundler. This configuration file tells rollup how to compile and build your app. If your prefer `webpack`, you can create your starter project with `npx degit sveltejs/template-webpack`
- `src`: This directory is where the source code for your application lives - where you will be creating the code for your app.
	- `App.svelte` - This is the top-level component of your app.
	- `main.js` - The entry point to our application. It just instantiate the `App` component and binds it to the body of our HTML page.
- `public`: This directory contains all the filles that will be published in production.
	- `index.html`: This is the main page of our app. Initially it is just an empty HTML page that loads the CSS files and js bundles generated by Svelte.
	- `global.css`: This file contains unscoped styles. It is a regular CSS file that will be applied to the whole application.
	- `build`: This folder contains the generated CSS and JavaScript source code.

## Having a look at our first Svelte component

Components are the building blocks of Svelte applications. They are written into `.svelte` files using a superset of HTML.

All there sections - `<script>`, `<style>`, and markup - are optional, and can appear in any order you like.

```
<script>
  // logic goes here
</script>

<style>
  /* styles go here */
</style>

<!-- markup (zero or more HTML elements) goes here -->

```

### The `<script>` section

The `<script>` block contains JavaScript that runs when a component instance is created. Variables declared (or imported) at the top level are 'visible' from the component's markup. Top-level variables are the way Svelte handles the component state, and they are reactive by default. 

```
<script>
  export let name;
</script>
```

Svelte uses the `export` keyword to mark a variable declaration as a property (or prop), which means it becomes accessible to consumers of the component (eg. other components). 

### The markup section

In the markup section you can insert any HTML you like, and in addition you can insert valid JavaScript expressions inside singly curly brackets (`{ }`).  In this case we are embedding the value of the `name` prop right after the `Hello` text.

```
<main>
  <h1>Hello {name}!</h1>
</main>
```

Svelte also supports tags like `{#if}`, `{#each}`, and `{#await}` - these directives or tags allow you to conditionally render a portion of the markup, iterate through a list of elements, and work with async values, respectively. 

### The `<style>` section

In Svelte, CSS inside a component's `<style>` block will be scoped only to that component. This works by adding a class to selected elements, which is based on a hash of the component styles. 

```
<h1 class="svelte-1tky8bj">
```

> You can override this behavior and apply styles to a selector globally using the `:global()` modifier.

## A first look at Svelte reactivity

In the context of a UI framework, reactivity means that the framework can automatically update the DOM when the state of any component is changed.

In Svelte, reactivity is triggered by assigning a new value to any top-level variable in a component. For example, we could include a `toggleName` function in our `App` component, and a button to run it.

```
<script>
  export let name;

  function toggleName() {
    if (name === "world") {
      name = "Svelte";
    } else {
      name = "world";
    }
  }
</script>

<main>
  <h1>Hello {name}!</h1>
  <button on:click="{toggleName}">Toggle name</button>
</main>
```

Whenever the button is clicked, Svelte executes the `toggleName()` function, which in turn updates the value of the `name` variable. 

The `<h1>` label is automatically updated. Behind the scenes, Svelte created the JavaScript code to update the DOM whenever the value of the name variable changes, without using any virtual DOM or other complex reconciliation mechanism.

Note the use of `:` in `on:click` That's Svelte's syntax for listening to DOM events.

## Inspecting `main.js`: the entry point on our app

Let's open `src/main.js`, which is where the `App` component is being imported and used. This file is the entry point for our app, and it initially looks like this:

```
import App from "./App.svelte";

const app = new App({
  target: document.body,
  props: {
    name: "world",
  },
});

export default app;

```

`main.js` starts by importing the Svelte component that we are going to use. Then, it instantiates it, passing an option object with the following properties:
- `target`: The DOM element inside which we want the component to be rendered, in this case the `<body>` element.
- `props`: the values to assign to each prop of the `App` component.

## A look under the hood

How does Svelte manage to make all these files work together nicely?

The Svelte compiler processes the `<style>` section of every component and compiles them into the `public/build/bundle.css` file.

It also compiles the markup and `<script>` section of every component and stores that result in `public/build/bundle.js`. It also adds the code in `src/main.js` to reference the features of every component. 

Finally the file `public/index.html` includes the generated `bundle.css` and `bundle.js` files.

## Conditional Statement

In Svelte, you can create conditional statement using the `{#if}` directive. The syntax is as follows:
```
{#if condition}
	<!---HTML ---->
{/if}
```

You can also use an `{else}` block to specify what to do if the condition  is not met:

```
{#if condition}

{:else if condition}

{:else}
  
{/if}
```

## Loop through an Array

In Svelte, you can create a `foreach` loop using the `{#each}` directive. The syntax is as follows:

```
{#each array as item (index)}
  <!-- code to be executed for each item in the array -->
{/each}

```


For example:
```
<script>
  let numbers = [1, 2, 3, 4, 5];
</script>

<ul>
  {#each numbers as number (index)}
    <li>{index + 1}. {number}</li>
  {/each}
</ul>

```

In the above example, `number` is the current item in the `numbers` array, and `index` as its index. The `(index)` syntax is optional, and you can omit it if you do not need it in your loop.

## Loop through an Object

In Svelte, you can loop through an object using the `{#each}` directive in a similar way as with arrays. However, since objects don't have a guaranteed order, you will need to extract the object's keys first, and then use those keys to access the values. Here is an example:

```
<script>
  let person = {
    name: 'John Doe',
    age: 30,
    city: 'New York'
  };
</script>

<ul>
  {#each Object.keys(person) as key}
    <li>{key}: {person[key]}</li>
  {/each}
</ul>

```

In the above example, `Object.keys(person)` returns an array of the object's keys, which we can then use in the `{#each}` loop to access the values.


